package net.floodlightcontroller.applications.fade.flow.singleflow;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import net.floodlightcontroller.applications.appmodule.rulegraph.IRuleGraphListener;
import net.floodlightcontroller.applications.appmodule.rulegraph.IRuleGraphService;
import net.floodlightcontroller.applications.appmodule.rulegraph.IRuleNode;
import net.floodlightcontroller.applications.fade.exception.InvalidArgumentException;
import net.floodlightcontroller.applications.fade.flow.Flow;
import net.floodlightcontroller.applications.fade.flow.FlowNode;
import net.floodlightcontroller.applications.fade.flow.FlowSelector;
import net.floodlightcontroller.applications.fade.util.AutoLock;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.*;

/**
 * Selector for single flow.
 * We build flows according to the events generated by {@link IRuleGraphService}
 */
public class SingleFlowSelector implements FlowSelector, IRuleGraphListener {

    private static final Logger logger = LoggerFactory.getLogger(SingleFlowSelector.class);

    private IRuleGraphService ruleGraphService = null;

    private ReadWriteLock flowLock;
    private Map<SingleFlow, Long> flowPriority = null;
    private PriorityQueue<SingleFlow> flows = null;
    private ConcurrentMap<IRuleNode, List<SingleFlow>> ruleMap = null;
    private ReentrantLock dumpLock = new ReentrantLock();

    public SingleFlowSelector(IRuleGraphService ruleGraphService){
        this.ruleGraphService = ruleGraphService;
        this.flowLock = new ReentrantReadWriteLock();
        this.flowPriority = Maps.newHashMap();
        this.flows = new PriorityQueue<SingleFlow>(Comparator.comparingLong(flow -> flowPriority.getOrDefault(flow, 0L)));
        this.ruleMap = Maps.newConcurrentMap();
        this.ruleGraphService.addListener(this);
    }

    @Override
    public List<Flow> getFlows(int limit) {
        if(limit <= 0){
            limit = Integer.MAX_VALUE;
        }
        if(limit > this.flows.size()){
            return this.getAllFlows();
        }
        List<Flow> result = Lists.newArrayListWithCapacity(limit);
        this.flowLock.writeLock().lock();
        try {
            // re-calculate the limit
            limit = Math.min(limit, this.flows.size());
            for (int i = 0; i < limit; i++) {
                // retrieve flow, and reset its priority, and then add it to flows again
                SingleFlow flow = this.flows.poll();
                result.add(flow);
                this.resetPriority(flow);
                this.flows.add(flow);
            }
        } finally {
            this.flowLock.writeLock().unlock();
        }
        return result;
    }

    @Override
    public List<Flow> getAllFlows() {
        this.flowLock.readLock().lock();
        try {
            return Lists.newArrayList(this.flows);
        } finally {
            this.flowLock.readLock().unlock();
        }
    }

    @Override
    public void ruleAdded(IRuleNode node) {
        if(this.ruleMap.containsKey(node)){
            logger.warn("duplicated ruleAdded message: {}, rule node has existed.", node);
            return;
        } else {
            // new flow
            SingleFlowNode sfNode = new SingleFlowNode(node);
            SingleFlow sf = new SingleFlow();
            sf.addNode(sfNode);
            this.flowLock.writeLock().lock();
            try{
                this.resetPriority(sf);
                this.ruleMap.put(node, new LinkedList<>());
                this.ruleMap.get(node).add(sf);
                this.flows.add(sf);
            } finally {
                this.flowLock.writeLock().unlock();
            }
        }
        this.dumpFlows();
    }

    @Override
    public void ruleRemoved(IRuleNode node) {
        // check flows
        if(!this.ruleMap.containsKey(node)){
            logger.warn("the node do not exist: {}", node);
            return;
        }
        List<SingleFlow> flows = this.ruleMap.get(node);
        this.flowLock.writeLock().lock();
        try{
            for(SingleFlow sf : flows){
                List<SingleFlowNode> flowNodes = (List<SingleFlowNode>) sf.getFlowNode();
                this.flows.remove(sf);
                List<SingleFlow> subflows = sf.split(node);
                // change the rule map of the subflow
                sf.getFlowNode().forEach( fn -> {
                    this.ruleMap.get(fn.getRuleNode()).remove(sf);
                });
                subflows.forEach( sub -> {
                    sub.getFlowNode().forEach( fn -> {
                        this.ruleMap.get(fn.getRuleNode()).add(sub);
                    });
                    this.resetPriority(sub);
                });
            }
        } finally {
            this.flowLock.writeLock().unlock();
        }
        // clear rule map
        this.ruleMap.remove(node);
        this.dumpFlows();
    }

    @Override
    public void ruleModified(IRuleNode node) {
        this.ruleRemoved(node);
        this.ruleAdded(node);
    }

    @Override
    public void linkAdded(IRuleNode prev, IRuleNode next) {
        this.flowLock.writeLock().lock();
        try {
            // get subflow before prev, return an default empty node if there is no prev
            // copy the list as we would modify it in the function clearFlow
            List<SingleFlow> prevFlows = Lists.newArrayList(this.ruleMap.getOrDefault(prev, Collections.singletonList(new SingleFlow())));
            Set<List<SingleFlowNode>> prevFlowNodes = Sets.newHashSet();
            for (SingleFlow sf : prevFlows) {
                int idxOfPrev = this.getIndexOfRuleNode(sf, prev);
                if (-1 == idxOfPrev) {// default empty node
                    prevFlowNodes.add(Collections.singletonList(new SingleFlowNode(prev)));
                } else {
                    prevFlowNodes.add( sf.getFlowNode().subList(0, idxOfPrev + 1));
                }
                if (idxOfPrev == sf.getFlowNode().size() - 1) { // at the end of the flow
                    this.clearFlow(sf);
                }
            }
            // get subflow after next ( return a default empty node if there is no next )
            List<SingleFlow> nextFlows = Lists.newArrayList(this.ruleMap.getOrDefault(next, Collections.singletonList(new SingleFlow())));
            Set<List<SingleFlowNode>> nextFlowNodes = Sets.newHashSet();
            for (SingleFlow sf : nextFlows) {
                int idxOfNext = this.getIndexOfRuleNode(sf, next);
                if (-1 == idxOfNext) {// default empty node
                    nextFlowNodes.add(Collections.singletonList(new SingleFlowNode(next)));
                } else {
                    nextFlowNodes.add( sf.getFlowNode().subList(idxOfNext, sf.getFlowNode().size()));
                }
                if (0 == idxOfNext) {
                    this.clearFlow(sf);
                }
            }
            // merge
            for(List<SingleFlowNode> prevNodes : prevFlowNodes){
                for(List<SingleFlowNode> nextNodes : nextFlowNodes){
                    List<SingleFlowNode> nodes = Lists.newArrayListWithCapacity(prevNodes.size() + nextNodes.size());
                    nodes.addAll(prevNodes);
                    nodes.addAll(nextNodes);
                    SingleFlow sf = new SingleFlow(nodes);
                    this.addFlow(sf);
                }
            }
        } finally {
            this.flowLock.writeLock().unlock();
        }
    }

    @Override
    public void linkRemoved(IRuleNode prev, IRuleNode next) {
        // split the flow into two flows
        this.flowLock.writeLock().lock();
        try{
            List<SingleFlow> prevFlows = Lists.newArrayList(this.ruleMap.getOrDefault(prev, Collections.emptyList()));
            if(prevFlows.size() != 0){
                prevFlows.forEach(sf -> {
                    int idxPrev = this.getIndexOfRuleNode(sf, prev);
                    if(idxPrev != -1 &&
                            idxPrev+1 < sf.getFlowNode().size() &&
                            ((SingleFlowNode)sf.getFlowNode().get(idxPrev+1)).getRuleNode().equals(next)){
                        // find the flow
                        FlowNode splitPoint = sf.getFlowNode().get(idxPrev);
                        List<SingleFlow> subflows = sf.split(splitPoint);
                        // update rule map
                        this.clearFlow(sf);
                        subflows.forEach( sub -> {
                            sub.getFlowNode().forEach( fn -> {
                                if (!this.ruleMap.containsKey(fn.getRuleNode())){
                                    this.ruleMap.put(fn.getRuleNode(), Lists.newArrayList());
                                }
                                this.ruleMap.get(fn.getRuleNode()).add(sub);
                            });
                            this.resetPriority(sub);
                            this.flows.add(sub);
                        });
                    }
                });
            }
        } finally {
            this.flowLock.writeLock().unlock();
        }
    }

    private int getIndexOfRuleNode(SingleFlow flow, IRuleNode ruleNode) {
        int idx = 0;
        List<SingleFlowNode> flowNodes = (List<SingleFlowNode>) flow.getFlowNode();
        while (idx < flowNodes.size() && !flowNodes.get(idx).getRuleNode().equals(ruleNode))
            idx++;
        return idx == flowNodes.size() ? -1 : idx;
    }

    private void resetPriority(SingleFlow flow){
        // use timestamp as priority
        long timestamp = Calendar.getInstance().getTimeInMillis();
        this.flowPriority.put(flow, timestamp);
    }

    private void clearFlow(SingleFlow sf){
        this.flows.remove(sf);
        this.flowPriority.remove(sf);
        for(SingleFlowNode sfn : (List<SingleFlowNode>) sf.getFlowNode()){
            if(this.ruleMap.containsKey(sfn.getRuleNode()) && this.ruleMap.get(sfn.getRuleNode()).size() == 1){
                this.ruleMap.remove(sfn.getRuleNode());
            } else {
                this.ruleMap.get(sfn.getRuleNode()).remove(sf);
            }
        }
    }

    private void addFlow(SingleFlow sf){
        for(SingleFlowNode sfn : (List<SingleFlowNode>) sf.getFlowNode()){
            if(!this.ruleMap.containsKey(sfn.getRuleNode())){
                this.ruleMap.put(sfn.getRuleNode(), Lists.newArrayList());
            }
            this.ruleMap.get(sfn.getRuleNode()).add(sf);
        }
        this.resetPriority(sf);
        this.flows.add(sf);
    }

    private void dumpFlows(){
        if(logger.isDebugEnabled()) {
            try(AutoLock l1 = new AutoLock(this.flowLock.readLock())) {
                try (AutoLock l2 = new AutoLock(this.dumpLock)) {
                    logger.debug("----- SINGLE FLOW SELECTOR INFO -----");
                    StringBuilder sb = new StringBuilder();
                    this.flows.forEach(flow -> sb.append(flow).append(", "));
                    logger.debug(sb.toString());
                    logger.debug("----- SINGLE FLOW SELECTOR INFO END -----");
                }
            }
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("SingleFlowSelector[");
        sb.append("flows=").append(this.flows.size());
        sb.append("]");
        return sb.toString();
    }
}
